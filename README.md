# PPS

## Homework 30/07/2024

---

## Charles Babbage: The Father of the Computer

Charles Babbage was an English inventor and mathematician who is often called the "father of the computer." His ideas and designs for mechanical computing machines were the early steps toward the development of modern computers.

In the early 1800s, Babbage noticed that human calculations, such as those used for navigation and engineering, often contained errors and were very time-consuming. To solve this problem, he came up with the idea of creating a machine that could perform calculations automatically. In 1822, he proposed the "Difference Engine," a mechanical calculator designed to compute and print mathematical tables. Although Babbage built a small part of this machine and proved that it worked, he never finished the full project due to financial and technical difficulties.

Not giving up, Babbage began working on a more advanced machine called the "Analytical Engine" in the 1830s and 1840s. This new machine was much more ambitious and is considered the first concept of a general-purpose computer. The Analytical Engine could be programmed to perform any calculation or algorithm, much like modern computers. It used punched cards to input instructions, a concept borrowed from the Jacquard loom, which used punched cards to control weaving patterns.

The Analytical Engine had several parts similar to those in modern computers. It had a "mill" for processing calculations, which is like today's CPU (central processing unit), and a "store" for holding data, which is similar to modern memory. Babbage also included ideas for features like conditional branching and loops, allowing the machine to make decisions and perform repeated tasks.

Although the Analytical Engine was never built during Babbage's lifetime, his detailed plans and descriptions were incredibly influential. Ada Lovelace, a mathematician who worked with Babbage, recognized the machine's potential beyond simple calculations. She wrote the first algorithm intended for the machine, making her the world's first computer programmer.

Charles Babbage's visionary ideas were far ahead of his time, and it took many more years for technology to catch up. His work laid the foundational principles for the computers we use today, making a significant impact on the world of technology.

---

## Output Devices

Output devices are hardware components used to convey information from a computer to the user. Here is a list of various output devices along with additional information:

1. **Monitor**
   - **Description**: Displays visual output from the computer, such as the operating system interface and applications.
   - **Types**: CRT (Cathode Ray Tube), LCD (Liquid Crystal Display), LED (Light Emitting Diode), OLED (Organic Light Emitting Diode).

2. **Printer**
   - **Description**: Produces a physical copy of digital documents and images.
   - **Types**: Inkjet, Laser, Dot Matrix, 3D Printer.

3. **Projector**
   - **Description**: Projects visual output onto a screen or surface, useful for presentations and large displays.
   - **Types**: DLP (Digital Light Processing), LCD, LCoS (Liquid Crystal on Silicon).

4. **Speakers**
   - **Description**: Output audio from the computer, including music, sound effects, and system alerts.
   - **Types**: Wired, Wireless, Bluetooth.

5. **Headphones**
   - **Description**: Personal audio output device worn on or over the ears.
   - **Types**: Wired, Wireless, Over-Ear, On-Ear, In-Ear.

6. **Plotter**
   - **Description**: Produces large-scale prints and drawings, often used for technical diagrams and architectural blueprints.
   - **Types**: Inkjet Plotter, Laser Plotter.

7. **VR Headset**
   - **Description**: Provides immersive visual and audio output for virtual reality experiences.
   - **Examples**: Oculus Rift, HTC Vive, PlayStation VR.

8. **LCD/LED Display Panels**
   - **Description**: Provide high-resolution visual output with different technologies for backlighting and color accuracy.
   - **Applications**: Monitors, TVs, digital signage.

9. **Smartboard/Interactive Whiteboard**
   - **Description**: Interactive display that allows users to engage with content directly on the screen.
   - **Applications**: Education, presentations, collaborative work.

10. **Braille Reader**
    - **Description**: Converts digital text into Braille for visually impaired users.
    - **Types**: Braille Embosser, Braille Display.

11. **Haptic Feedback Devices**
    - **Description**: Provide tactile feedback to simulate touch and motion sensations.
    - **Applications**: Gaming controllers, VR gloves.

12. **3D Printer**
    - **Description**: Creates three-dimensional objects from digital models by adding material layer by layer.
    - **Types**: FDM (Fused Deposition Modeling), SLA (Stereolithography), SLS (Selective Laser Sintering).

13. **Television**
    - **Description**: A display device for broadcasting and multimedia content.
    - **Types**: LCD, LED, OLED, Plasma.

14. **Digital Signage**
    - **Description**: Electronic displays used for advertising, information, and communication.
    - **Applications**: Retail, transportation, public information.

15. **Sound Card (for audio output)**
    - **Description**: Hardware component that processes audio signals and produces sound output.
    - **Types**: Integrated (built into the motherboard), Dedicated (external or internal expansion card).

---

## Input Devices

Input devices are hardware components used to provide data and control signals to a computer. Here is the list of input devices along with additional information:

1. **Touchscreen**
   - **Description**: A display that also serves as an input device by detecting touch gestures.
   - **Types**: Capacitive, Resistive, Optical, Infrared.

2. **Trackpad/Touchpad**
   - **Description**: A flat surface that detects finger movements to control the cursor on a screen.
   - **Applications**: Laptops, some desktop keyboards.

3. **Joystick**
   - **Description**: A control device used to move an on-screen object or navigate through menus.
   - **Applications**: Gaming, flight simulators.

4. **Game Controller**
   - **Description**: Handheld device used to interact with video games.
   - **Types**: Wired, Wireless, Bluetooth.

5. **Stylus/Pen Tablet**
   - **Description**: A pen-like tool used to draw or write directly on a digital surface.
   - **Applications**: Graphic design, note-taking.

6. **Microphone**
   - **Description**: Captures audio input and converts it into digital signals.
   - **Types**: Dynamic, Condenser, Lavalier, USB.

7. **Scanner**
   - **Description**: Converts physical documents or images into digital format.
   - **Types**: Flatbed, Sheet-fed, Drum, Handheld.

8. **Webcam**
   - **Description**: Captures video input and transmits it over the internet or records it.
   - **Applications**: Video conferencing, streaming.

9. **Barcode Reader**
   - **Description**: Scans and interprets barcodes to input data into a computer.
   - **Types**: Handheld, Fixed, Wireless.

10. **Magnetic Stripe Reader**
    - **Description**: Reads data from magnetic stripes on cards (e.g., credit cards).
    - **Applications**: Payment systems, access control.

11. **Biometric Scanner (Fingerprint, Iris)**
    - **Description**: Captures and analyzes biometric data for authentication.
    - **Types**: Fingerprint scanners, Iris scanners.

12. **MIDI Keyboard**
    - **Description**: Musical instrument interface that sends data to a computer or synthesizer.
    - **Applications**: Music production, digital composition.

13. **Graphics Tablet**
    - **Description**: An input device that allows users to draw or write directly onto a digital surface.
    - **Applications**: Digital art, graphic design.

14. **VR Controllers**
    - **Description**: Handheld controllers used in virtual reality environments for interaction.
    - **Applications**: VR gaming, simulations.

15. **Light Pen**
    - **Description**: A pointing device that detects light from a screen and allows users to interact directly with display elements.
    - **Applications**: Early graphics systems, drawing applications.

16. **Digital Camera**
    - **Description**: Captures photographs and videos in digital format.
    - **Applications**: Photography, video recording.

17. **Foot Pedal (used in transcription)**
    - **Description**: A pedal used to control playback of audio during transcription tasks.
    - **Applications**: Transcription, audio editing.



---

## Definition and Full Form of Computer

**Computer**: A computer is an electronic device that manipulates information or data. It has the ability to store, retrieve, and process data. Computers are used to perform a variety of tasks, including word processing, internet browsing, gaming, programming, and data analysis.

**Full Form of Computer**: Common Operating Machine Purposely Used for Technological and Educational Research.

---

# Homework 1/08/2024

# **Difference between Volatile memory and Non-Volatile Memory**


| **Feature**              | **Volatile Memory**                                      | **Non-Volatile Memory**                                  |
|--------------------------|-----------------------------------------------------------|----------------------------------------------------------|
| **Definition**           | Requires power to maintain data; data is lost when power is off | Retains data without power; data is preserved when power is off |
| **Examples**             | - RAM (Random Access Memory) <br> - Cache Memory <br> - Registers | - Hard Drives (HDDs) <br> - Solid-State Drives (SSDs) <br> - Flash Memory (USB drives, SD cards) <br> - ROM (Read-Only Memory) |
| **Speed**                | Typically faster; allows quick access to data          | Generally slower; SSDs offer faster speeds compared to HDDs |
| **Data Retention**       | Loses data when power is off                             | Retains data without power                               |
| **Primary Use**          | Temporary storage for data currently being processed    | Long-term storage for operating systems, applications, and user data |
| **Cost**                 | Generally less expensive per byte compared to non-volatile memory | Typically more expensive per byte than volatile memory, though prices vary |
| **Volatility**           | High; data is volatile and needs constant power          | Low; data is non-volatile and remains intact without power |
| **Write Endurance**      | Not applicable (focuses on speed and temporary storage)  | Varies; SSDs and flash memory have limited write cycles, but HDDs have virtually unlimited write endurance |
| **Capacity**             | Often used in smaller capacities due to cost and function | Used for larger capacities; ideal for bulk storage       |
| **Performance Impact**   | Crucial for system performance and speed in multitasking | Affects boot time and load times; performance varies based on type (HDD vs SSD) |
| **Examples in Devices**  | - Desktop/Laptop RAM <br> - Smartphone RAM <br> - CPU cache | - Personal computers (SSD/HDD) <br> - USB flash drives <br> - Embedded systems (firmware in ROM) |

---

# RAM (Random Access Memory)

RAM (Random Access Memory) is a type of computer memory that can be accessed randomly. Any byte of memory can be accessed without touching the preceding bytes. It is used to store data that is actively being worked on or processed by the CPU, making it crucial for system performance.

## Types of RAM

### 1. SRAM (Static RAM)
- **How It Works**: SRAM uses flip-flops to store each bit of data. It retains data as long as power is supplied and doesn’t need to be periodically refreshed.
- **Speed**: Faster than DRAM.
- **Cost**: More expensive due to its complexity and the amount of circuitry needed.
- **Usage**: Often used for cache memory in CPUs.

### 2. DRAM (Dynamic RAM)
- **How It Works**: DRAM stores each bit of data in a separate capacitor within an integrated circuit. The data needs to be refreshed periodically because capacitors leak charge.
- **Speed**: Slower compared to SRAM due to the need for refreshing.
- **Cost**: Less expensive than SRAM, making it more suitable for larger memory requirements.
- **Usage**: Commonly used for main system memory in computers.

### 3. DDR RAM (Double Data Rate RAM)
- **How It Works**: DDR RAM is a type of DRAM that improves performance by transferring data on both the rising and falling edges of the clock signal, effectively doubling the data rate.
- **Speed**: Faster than traditional SDRAM (Synchronous DRAM).
- **Generations**:
  - **DDR (DDR1)**: The original standard.
  - **DDR2**: Improved speed and efficiency over DDR.
  - **DDR3**: Further improvements in speed and power efficiency.
  - **DDR4**: Offers even higher speeds and lower power consumption.
  - **DDR5**: The latest generation, providing even higher performance and bandwidth.

## Summary
- **SRAM**: Fast but expensive; used in small quantities for cache.
- **DRAM**: Slower but cheaper; used for main system memory.
- **DDR RAM**: A type of DRAM with enhanced performance due to double data rate capability; comes in several generations with progressively better performance and efficiency.

---

# What is an Operating System (OS)?

An **Operating System (OS)** is system software that manages a computer's hardware and software resources and provides common services for computer programs. The OS acts as an intermediary between the user and the computer hardware, facilitating interaction and enabling software applications to run effectively.

## Different Kinds of Operating Systems

### 1. Batch Operating Systems
- **Purpose**: To handle batch processing of jobs without user interaction. Jobs are collected, processed, and executed sequentially.
- **Example**: IBM’s OS/360.
- **Use Case**: Ideal for environments where tasks are processed in bulk and do not require immediate user feedback, such as in early mainframe computers.

### 2. Time-Sharing Operating Systems
- **Purpose**: To allow multiple users to interact with the computer simultaneously by sharing time on a single processor.
- **Example**: UNIX, Multics.
- **Use Case**: Suitable for environments with multiple users needing interactive access, such as academic institutions and research facilities.

### 3. Multi-Tasking Operating Systems
- **Purpose**: To allow multiple processes or applications to run concurrently. The OS manages and allocates resources to these processes.
- **Example**: Windows, macOS, Linux.
- **Use Case**: Common in personal computers and servers where users need to run several applications at once, such as web browsing, document editing, and multimedia.

### 4. Real-Time Operating Systems (RTOS)
- **Purpose**: To ensure that processes are executed within a strict time constraint. It guarantees specific timing and performance levels.
- **Example**: VxWorks, QNX, RTEMS.
- **Use Case**: Critical for applications requiring precise timing and reliability, such as embedded systems in automotive controls, medical devices, and industrial automation.

### 5. Embedded Operating Systems
- **Purpose**: To run on embedded systems designed for specific tasks. These OS are optimized for performance and resource constraints.
- **Example**: Android (for smartphones), FreeRTOS, Embedded Linux.
- **Use Case**: Found in consumer electronics like smartphones, tablets, and IoT devices where specialized and efficient performance is necessary.

### 6. Network Operating Systems (NOS)
- **Purpose**: To manage network resources and provide services to connected computers. It handles tasks such as file sharing, user management, and network security.
- **Example**: Windows Server, Novell NetWare.
- **Use Case**: Used in server environments to control and manage networked systems, facilitating file sharing and resource management across a network.

### 7. Distributed Operating Systems
- **Purpose**: To manage a group of interconnected computers as if they were a single cohesive system. It coordinates resources and processes across multiple machines.
- **Example**: Google’s Android (distributed architecture), Amoeba.
- **Use Case**: Useful for large-scale computing environments where resources are spread over multiple machines but need to operate as a unified system, such as cloud computing platforms.

## Summary
- **Batch OS**: Processes jobs in batches without user interaction, suitable for bulk processing tasks.
- **Time-Sharing OS**: Supports multiple users interacting simultaneously, ideal for shared computing environments.
- **Multi-Tasking OS**: Manages concurrent applications, used in personal and server computers.
- **Real-Time OS**: Ensures strict timing requirements, critical for embedded and industrial systems.
- **Embedded OS**: Optimized for specific devices with limited resources, used in consumer electronics and IoT devices.
- **Network OS**: Manages network resources and services, essential for server and network management.
- **Distributed OS**: Coordinates resources across multiple computers, used in large-scale and cloud computing systems.

Each type of OS is tailored to meet the specific needs of its environment and applications, ensuring optimal performance and functionality.

## Homework 6/08/2024

## Compiler, Interpreter, Assembler, Loader, and Linker

## 1. Compiler

**Definition**: A compiler is a program that translates high-level programming code into machine code or intermediate code that a computer’s processor can execute directly.

**Process**:
- **Lexical Analysis**: Converts the source code into tokens.
- **Syntax Analysis**: Checks the tokens against grammar rules to form a parse tree.
- **Semantic Analysis**: Ensures that the parse tree follows the rules of the programming language.
- **Optimization**: Improves the efficiency of the code.
- **Code Generation**: Converts the optimized intermediate representation into machine code.

**Output**: Typically generates an object file (`.obj` or `.o`) containing machine code or intermediate code.

**Example**: GCC for C/C++ or `javac` for Java.

## 2. Interpreter

**Definition**: An interpreter directly executes the instructions written in a programming language without requiring them to be compiled into machine code beforehand.

**Process**:
- **Lexical Analysis**: Similar to a compiler, it breaks down the source code into tokens.
- **Parsing**: Converts tokens into a data structure.
- **Execution**: Executes the instructions directly, usually by interpreting the parsed data structure.

**Output**: Directly executes the code, usually without producing a separate machine code file.

**Example**: Python’s CPython interpreter or the JavaScript engine in a web browser.

## 3. Assembler

**Definition**: An assembler translates assembly language, which is a low-level language with a strong correspondence to machine code, into machine code.

**Process**:
- **Parsing**: Reads the assembly language source code.
- **Symbol Resolution**: Maps symbolic names to memory addresses or machine code.
- **Code Generation**: Produces the corresponding machine code.

**Output**: Generates object files (`.obj` or `.o`) that contain machine code, similar to what a compiler produces.

**Example**: NASM (Netwide Assembler) or MASM (Microsoft Assembler).

## 4. Loader

**Definition**: A loader is responsible for loading the compiled object files or executable files into memory and preparing them for execution.

**Process**:
- **Loading**: Places the executable or object code into the system's memory.
- **Relocation**: Adjusts addresses in the code so that it can run correctly regardless of where it was loaded in memory.
- **Linking**: Resolves addresses for libraries or external references.

**Output**: A ready-to-execute program in memory.

**Example**: The operating system’s built-in loader or dynamic loaders for shared libraries.

## 5. Linker

**Definition**: A linker combines multiple object files into a single executable or library. It resolves references between these files, such as function calls or variable accesses.

**Process**:
- **Symbol Resolution**: Matches function calls and variable accesses with their definitions.
- **Relocation**: Adjusts addresses in the object code to reflect their final positions in memory.
- **Library Linking**: Links with libraries to include necessary functions or routines.

**Output**: An executable file (`.exe`, `.out`) or a library file (`.lib`, `.dll`).

**Example**: GNU `ld` or Microsoft’s `link.exe`.

## How They Work Together

1. **Writing Code**: The developer writes code in a high-level language.
2. **Compilation**: The compiler translates this code into an object file containing machine code.
3. **Assembly (if needed)**: If the code is in assembly language, it is first assembled into an object file.
4. **Linking**: The linker combines object files and resolves references, producing an executable.
5. **Loading**: The loader then loads this executable into memory and prepares it for execution.

In summary, the compiler, assembler, loader, and linker each play a vital role in transforming human-readable code into machine-executable programs. The interpreter, on the other hand, executes code directly and often does not involve these intermediate steps.

## Operating Systems: Types and Applications

## Applications of Operating Systems

1. **Managing Hardware Resources**:
    - Coordinates and controls the hardware components of a computer.
    - Examples: CPU, memory, disk drives, and printers.

2. **Providing a User Interface**:
    - Allows users to interact with the computer.
    - Examples: Graphical User Interface (GUI) and Command Line Interface (CLI).

3. **File Management**:
    - Organizes and keeps track of files and directories.
    - Examples: File creation, deletion, reading, writing, and permissions.

4. **Security and Access Control**:
    - Protects data and resources from unauthorized access.
    - Examples: User authentication, encryption, and firewall.

5. **Task Management**:
    - Manages the execution of processes and tasks.
    - Examples: Multitasking, process scheduling, and inter-process communication.

6. **Device Management**:
    - Manages device communication via their respective drivers.
    - Examples: Input/output operations and device status monitoring.

7. **Memory Management**:
    - Manages the computer's memory, including RAM and cache.
    - Examples: Allocation, deallocation, and virtual memory.

8. **Networking**:
    - Manages network connections and communication.
    - Examples: Protocol handling, data transmission, and network security.

## Types of Operating Systems

1. **Batch Operating System**:
    - Executes batches of jobs without manual intervention.
    - Example: IBM's OS/360.

2. **Time-Sharing Operating System**:
    - Allows multiple users to use the computer simultaneously by sharing time slices.
    - Example: UNIX.

3. **Distributed Operating System**:
    - Manages a group of distinct computers and makes them appear as a single computer.
    - Example: Amoeba, Plan 9.

4. **Network Operating System (NOS)**:
    - Provides networking functions to allow multiple computers to communicate.
    - Example: Microsoft Windows Server, Novell NetWare.

5. **Real-Time Operating System (RTOS)**:
    - Provides immediate processing and response to inputs.
    - Example: VxWorks, RTLinux.

6. **Mobile Operating System**:
    - Specifically designed for mobile devices.
    - Example: Android, iOS.

7. **Embedded Operating System**:
    - Designed to operate in embedded systems.
    - Example: FreeRTOS, Embedded Linux.

8. **Single-user, Single-tasking Operating System**:
    - Designed for one user to perform one task at a time.
    - Example: MS-DOS.

9. **Single-user, Multi-tasking Operating System**:
    - Allows one user to perform multiple tasks simultaneously.
    - Example: Microsoft Windows, macOS.

10. **Multi-user Operating System**:
    - Allows multiple users to use the system concurrently.
    - Example: UNIX, Linux.
## Storages

| **Unit**     | **Abbreviation** | **Value in Bytes**                       | **Definition**                                                                                                    | **Usage**                                                                                  |
|--------------|------------------|------------------------------------------|------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------|
| Bit          | b                | 1 bit                                    | The basic unit of information in computing and digital communications.                                            | Represents a binary value of 0 or 1.                                                      |
| Byte         | B                | 8 bits                                   | A unit of digital information that most commonly consists of 8 bits.                                              | Can represent 256 different values (2^8). Encodes a single character of text.             |
| Kilobyte     | KB               | 1,024 bytes (2^10 bytes)                 | 1,024 bytes.                                                                                                      | Used for smaller files like text documents.                                               |
| Megabyte     | MB               | 1,048,576 bytes (2^20 bytes)             | 1,024 KB.                                                                                                         | Commonly used to measure medium-sized files like photos and songs.                        |
| Gigabyte     | GB               | 1,073,741,824 bytes (2^30 bytes)         | 1,024 MB.                                                                                                         | Used for larger files and storage capacity like HD videos and smartphone storage.         |
| Terabyte     | TB               | 1,099,511,627,776 bytes (2^40 bytes)     | 1,024 GB.                                                                                                         | Measures high-capacity storage devices like external hard drives and cloud storage.       |
| Petabyte     | PB               | 1,125,899,906,842,624 bytes (2^50 bytes) | 1,024 TB.                                                                                                         | Used by large data centers and enterprises for large-scale storage.                       |
| Exabyte      | EB               | 1,152,921,504,606,846,976 bytes (2^60 bytes) | 1,024 PB.                                                                                                         | Used for extremely large data sets in data analysis and scientific research.              |
| Zettabyte    | ZB               | 1,180,591,620,717,411,303,424 bytes (2^70 bytes) | 1,024 EB.                                                                                                         | Quantifies the total amount of data in existence.                                         |
| Yottabyte    | YB               | 1,208,925,819,614,629,174,706,176 bytes (2^80 bytes) | 1,024 ZB.                                                                                                         | Theoretical unit for future data growth projections.                                      |


## Detailed Comparison of Assembler, Loader, Interpreter, Compiler, and Linker

| Feature                | Assembler                                                    | Loader                                                       | Interpreter                                                 | Compiler                                                   | Linker                                                     |
|------------------------|--------------------------------------------------------------|--------------------------------------------------------------|-------------------------------------------------------------|-------------------------------------------------------------|-------------------------------------------------------------|
| **Definition**         | Converts assembly language into machine code                 | Loads programs into memory for execution                     | Translates and executes code line-by-line                   | Translates entire code into machine code                    | Combines multiple object files into a single executable     |
| **Input**              | Assembly code                                                | Compiled or assembled code                                   | Source code                                                 | Source code                                                 | Object files or libraries                                   |
| **Output**             | Machine code or object code                                  | Program in memory, ready for execution                       | Immediate execution results                                 | Executable file or object code                              | Single executable file or library                           |
| **Execution**          | Not directly executable                                      | Prepares executable code for execution                       | Executes code during translation                            | Produces executable file to be executed later               | Executable file or library ready for execution              |
| **Error Detection**    | Limited to syntax errors in assembly language                | No error detection                                           | Immediate, during code execution                            | Syntax and semantic errors during compilation               | No error detection                                          |
| **Speed**              | Fast conversion                                              | Fast loading                                                 | Slower due to line-by-line execution                        | Generally faster execution as code is precompiled           | Fast, depends on the size of object files                   |
| **Memory Usage**       | Efficient, produces optimized machine code                   | Depends on program size                                      | Higher memory usage due to real-time interpretation         | Memory efficient as it produces optimized code              | Efficient, but depends on the number and size of object files|
| **Typical Use Cases**  | Low-level programming, embedded systems                      | Running any compiled or assembled program                    | Scripting languages like Python, JavaScript                 | High-level languages like C, C++, Java                      | Combining modules from large software projects              |
| **Examples**           | NASM, MASM                                                    | Operating system loaders                                     | Python Interpreter, Node.js                                 | GCC, Clang                                                  | GNU Linker, Microsoft Linker                                |
| **Role in Development**| Converts human-readable code to machine-readable instructions | Prepares and loads executable code into memory               | Provides real-time code execution for rapid development     | Transforms and optimizes code for efficient execution       | Integrates various code modules and resolves references     |


## Pseudocode example


### **Check Odd or Even**

1. **Start**
2. Read the value of `x`
3. **If** `x = 2n` then
   - Write "x is even"
4. **Else**
   - Write "x is odd"
5. **Close**

### **Simple Interest**

1. **Start**
2. Read the values of `P`, `R`, and `T`
3. Calculate `S.I` using the formula:
   S.I=[(P X R X T)]/100
4. Write the value of `S.I`
5. **Close**

### **18+ Age Check**

1. **Start**
2. Read the value of `A`
3. **If** `A ≥ 18` then
   - Write "Eligible to vote"
4. **Else**
   - Write "Not eligible to vote"
5. **Stop**

### **Check if Number is Imaginary**

1. **Start**
2. Read the value of `c = a + ib`
3. **If** `b = 0` then
   - Write "c is not imaginary"
4. **Else**
   - Write "c is imaginary"
5. **Close**

### **Fahrenheit to Celsius Conversion**

1. **Start**
2. Read the value of `F`
3. Calculate `C` using the formula:
   
   C = [5*(F - 32)]/9

4. Write the value of `C`
5. **Stop**

### **Radian to Degree Conversion**

1. **Start**
2. Read the value of `R`
3. Calculate `D` using the formula:
   
   D = [R*180]\pi
   
4. Write the value of `D`
5. **Stop**

### **Percentage Calculator**

1. **Start**
2. Read the values of `S1`, `S2`, `S3`, `S4`, and `S5`
3. Calculate the percentage using the formula:

   % = [(S1 + S2 + S3 + S4 + S5) \ 100]*5
   
4. Write the value of the percentage
5. **Stop**

### **Battery Checker**

1. **Start**
2. Read the value of `C`
3. **If** `C < 20` then
   - Write "Battery low"
4. **Else**
   - Write "Battery level OK"
5. **Stop**

### Algorithm: Convert Hours to Minutes

1. **Start**
2. **Input** the number of hours `h`.
3. **Calculate** the minutes by multiplying the hours by 60:
   - `minutes = h * 60`
4. **Output** the result (minutes).
5. **End**

### Algorithm: Check if a Number is Positive, Negative, or Zero

1. **Start**
2. **Input** the number `n`.
3. **Check Condition 1**: 
   - If `n > 0`, then the number is **positive**.
   - Go to Step 6.
4. **Check Condition 2**:
   - If `n < 0`, then the number is **negative**.
   - Go to Step 6.
5. **Else**:
   - If `n == 0`, then the number is **zero**.
6. **Output** the result (positive, negative, or zero).
7. **End**

---
